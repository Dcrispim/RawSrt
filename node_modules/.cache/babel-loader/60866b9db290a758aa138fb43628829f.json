{"ast":null,"code":"export const parsePSRTFileToObject = file => {\n  let out = {};\n  let currentPage = \"\";\n  let rawFile = new XMLHttpRequest();\n  rawFile.open(\"GET\", file, false);\n\n  rawFile.onreadystatechange = function () {\n    if (rawFile.readyState === 4) {\n      if (rawFile.status === 200 || rawFile.status == 0) {\n        out = { ...parsePSRTToObject(rawFile.responseText)\n        };\n      }\n    }\n  };\n\n  rawFile.send(null);\n  console.log(out);\n  return out;\n};\nexport const parsePSRTToObject = subtitle => {\n  let out = {};\n  let currentPage = \"\";\n  let i = 0;\n  let lastIndex = 0;\n  subtitle.split(\"\\n\").map(line => {\n    if (line.includes(\"$START\")) {\n      currentPage = line.substring(6).trim();\n      out[line.substring(6).trim()] = [];\n    } else if (line.includes(\"$END\")) {\n      currentPage = \"\";\n    } else if (line.includes(\">>\")) {\n      var _out$currentPage, _clearLine$split;\n\n      const clearLine = line.substring(2);\n      const [x, y, s, w] = clearLine.split(\" \")[0].split(\"-\");\n      (_out$currentPage = out[currentPage]) === null || _out$currentPage === void 0 ? void 0 : _out$currentPage.push({\n        index: clearLine.split(\" \")[2] ? parseInt(clearLine.split(\" \")[2]) : lastIndex + i,\n        x: parseFloat(x),\n        y: parseFloat(y),\n        size: parseFloat(s),\n        width: parseFloat(w),\n        style: JSON.parse((_clearLine$split = clearLine.split(\" \")) === null || _clearLine$split === void 0 ? void 0 : _clearLine$split[1])\n      });\n      lastIndex = clearLine.split(\" \")[2] ? parseInt(clearLine.split(\" \")[2]) : lastIndex;\n      i += 1;\n    } else if (line.length > 1) {\n      var _out$currentPage2;\n\n      if (((_out$currentPage2 = out[currentPage]) === null || _out$currentPage2 === void 0 ? void 0 : _out$currentPage2.length) > 0) {\n        var _out$currentPage3;\n\n        out[currentPage][((_out$currentPage3 = out[currentPage]) === null || _out$currentPage3 === void 0 ? void 0 : _out$currentPage3.length) - 1].text = line;\n      }\n    }\n  });\n  return out;\n};\nexport const parseObjectToPSRT = sub => {\n  let out = \"\";\n  Object.keys(sub).map(page => {\n    out += `$START ${page}\\n`;\n    sub[page].map(({\n      x,\n      y,\n      size,\n      width,\n      text,\n      style,\n      index\n    }, i) => {\n      out += `>>${x}-${y}-${size}-${width} ${JSON.stringify(style)} ${index || i}\\n`;\n      out += `${text}\\n\\n`;\n    });\n    out += `$END ${page}\\n\\n`;\n  });\n  return out;\n};","map":{"version":3,"sources":["/home/intelie/Documents/srt2/src/service/subtitle.ts"],"names":["parsePSRTFileToObject","file","out","currentPage","rawFile","XMLHttpRequest","open","onreadystatechange","readyState","status","parsePSRTToObject","responseText","send","console","log","subtitle","i","lastIndex","split","map","line","includes","substring","trim","clearLine","x","y","s","w","push","index","parseInt","parseFloat","size","width","style","JSON","parse","length","text","parseObjectToPSRT","sub","Object","keys","page","stringify"],"mappings":"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","sourcesContent":["export const parsePSRTFileToObject = (\n  file: string\n): {\n  [page: string]: {\n    x: number;\n    y: number;\n    index: number;\n    width: number;\n    size: number;\n    text: string;\n    style: React.CSSProperties;\n  }[];\n} => {\n  let out: { [k: string]: any } = {};\n  let currentPage = \"\";\n  let rawFile = new XMLHttpRequest();\n  rawFile.open(\"GET\", file, false);\n  rawFile.onreadystatechange = function () {\n    if (rawFile.readyState === 4) {\n      if (rawFile.status === 200 || rawFile.status == 0) {\n        out = { ...parsePSRTToObject(rawFile.responseText) };\n      }\n    }\n  };\n\n  rawFile.send(null);\n  console.log(out);\n\n  return out;\n};\n\nexport const parsePSRTToObject = (subtitle: string) => {\n  let out: { [k: string]: any } = {};\n  let currentPage = \"\";\n\n  let i = 0;\n  let lastIndex = 0;\n\n  subtitle.split(\"\\n\").map((line) => {\n    if (line.includes(\"$START\")) {\n      currentPage = line.substring(6).trim();\n      out[line.substring(6).trim()] = [];\n    } else if (line.includes(\"$END\")) {\n      currentPage = \"\";\n    } else if (line.includes(\">>\")) {\n      const clearLine = line.substring(2);\n      const [x, y, s, w] = clearLine.split(\" \")[0].split(\"-\");\n      out[currentPage]?.push({\n        index: clearLine.split(\" \")[2]\n          ? parseInt(clearLine.split(\" \")[2])\n          : lastIndex + i,\n        x: parseFloat(x),\n        y: parseFloat(y),\n        size: parseFloat(s),\n        width: parseFloat(w),\n        style: JSON.parse(clearLine.split(\" \")?.[1]),\n      });\n      lastIndex = clearLine.split(\" \")[2]\n        ? parseInt(clearLine.split(\" \")[2])\n        : lastIndex;\n\n      i += 1;\n    } else if (line.length > 1) {\n      if (out[currentPage]?.length > 0) {\n        out[currentPage][out[currentPage]?.length - 1].text = line;\n      }\n    }\n  });\n  return out;\n};\n\nexport const parseObjectToPSRT = (sub: {\n  [page: string]: {\n    x: number;\n    y: number;\n    width: number;\n    size: number;\n    text: string;\n    index: number;\n    style: React.CSSProperties;\n  }[];\n}): string => {\n  let out = \"\";\n\n  Object.keys(sub).map((page) => {\n    out += `$START ${page}\\n`;\n    sub[page].map(({ x, y, size, width, text, style, index }, i) => {\n      out += `>>${x}-${y}-${size}-${width} ${JSON.stringify(style)} ${\n        index || i\n      }\\n`;\n      out += `${text}\\n\\n`;\n    });\n    out += `$END ${page}\\n\\n`;\n  });\n  return out;\n};\n"]},"metadata":{},"sourceType":"module"}