{"ast":null,"code":"export const parsePSRTFileToObject = file => {\n  let out = {};\n  let currentPage = \"\";\n  let rawFile = new XMLHttpRequest();\n  rawFile.open(\"GET\", file, false);\n\n  rawFile.onreadystatechange = function () {\n    if (rawFile.readyState === 4) {\n      if (rawFile.status === 200 || rawFile.status == 0) {\n        out = { ...parsePSRTToObject(rawFile.responseText)\n        };\n      }\n    }\n  };\n\n  rawFile.send(null);\n  return out;\n};\nexport const parsePSRTToObject = subtitle => {\n  let out = {};\n  let currentPage = \"\";\n  let i = 0;\n  let lastIndex = 0;\n  subtitle.split(\"\\n\").map(line => {\n    if (line.includes(\"$START\")) {\n      currentPage = line.substring(6).trim().split(\"/\")[0];\n      out[currentPage] = [];\n\n      if (line.substring(6).trim().split(\"/\")[1]) {\n        out.__global_style__ = JSON.parse(line.substring(6).trim().split(\"/\")[1]);\n      }\n    } else if (line.includes(\"$END\")) {\n      currentPage = \"\";\n    } else if (line.includes(\">>\")) {\n      var _out$currentPage, _clearLine$split;\n\n      const clearLine = line.substring(2);\n      const [x, y, s, w] = clearLine.split(\"/\")[0].split(\"-\");\n      (_out$currentPage = out[currentPage]) === null || _out$currentPage === void 0 ? void 0 : _out$currentPage.push({\n        index: clearLine.split(\"/\")[2] ? parseInt(clearLine.split(\"/\")[2]) : lastIndex + i,\n        x: parseFloat(x),\n        y: parseFloat(y),\n        size: parseFloat(s),\n        width: parseFloat(w),\n        style: JSON.parse((_clearLine$split = clearLine.split(\"/\")) === null || _clearLine$split === void 0 ? void 0 : _clearLine$split[1])\n      });\n      lastIndex = clearLine.split(\"/\")[2] ? parseInt(clearLine.split(\"/\")[2]) : lastIndex;\n      i += 1;\n    } else if (line.length > 1) {\n      var _out$currentPage2;\n\n      if (((_out$currentPage2 = out[currentPage]) === null || _out$currentPage2 === void 0 ? void 0 : _out$currentPage2.length) > 0) {\n        var _out$currentPage3;\n\n        out[currentPage][((_out$currentPage3 = out[currentPage]) === null || _out$currentPage3 === void 0 ? void 0 : _out$currentPage3.length) - 1].text = line;\n      }\n    }\n  });\n  return out;\n};\nexport const parseObjectToPSRT = sub => {\n  let out = \"\";\n  Object.keys(sub).map(page => {\n    var _sub$page;\n\n    out += `$START ${page}\\n`;\n    (_sub$page = sub[page]) === null || _sub$page === void 0 ? void 0 : _sub$page.map(({\n      x,\n      y,\n      size,\n      width,\n      text,\n      style,\n      index\n    }, i) => {\n      out += `>>${x}-${y}-${size}-${width}/${JSON.stringify(style)}/${index || i}\\n`;\n      out += `${text}\\n\\n`;\n    });\n    out += `$END ${page}\\n\\n`;\n  });\n  return out;\n};","map":{"version":3,"sources":["/home/intelie/Documents/srt2/src/service/subtitle.ts"],"names":["parsePSRTFileToObject","file","out","currentPage","rawFile","XMLHttpRequest","open","onreadystatechange","readyState","status","parsePSRTToObject","responseText","send","subtitle","i","lastIndex","split","map","line","includes","substring","trim","__global_style__","JSON","parse","clearLine","x","y","s","w","push","index","parseInt","parseFloat","size","width","style","length","text","parseObjectToPSRT","sub","Object","keys","page","stringify"],"mappings":"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","sourcesContent":["export const parsePSRTFileToObject = (\n  file: string\n): {\n  [page: string]: {\n    x: number;\n    y: number;\n    index: number;\n    width: number;\n    size: number;\n    text: string;\n    style: React.CSSProperties;\n  }[];\n} => {\n  let out: { [k: string]: any } = {};\n  let currentPage = \"\";\n  let rawFile = new XMLHttpRequest();\n  rawFile.open(\"GET\", file, false);\n  rawFile.onreadystatechange = function () {\n    if (rawFile.readyState === 4) {\n      if (rawFile.status === 200 || rawFile.status == 0) {\n        out = { ...parsePSRTToObject(rawFile.responseText) };\n      }\n    }\n  };\n\n  rawFile.send(null);\n\n  return out;\n};\n\nexport const parsePSRTToObject = (subtitle: string) => {\n  let out: { [k: string]: any } = {};\n  let currentPage = \"\";\n\n  let i = 0;\n  let lastIndex = 0;\n\n  subtitle.split(\"\\n\").map((line) => {\n    if (line.includes(\"$START\")) {\n      currentPage = line.substring(6).trim().split(\"/\")[0];\n      out[currentPage] = [];\n      if (line.substring(6).trim().split(\"/\")[1]) {\n        out.__global_style__ = JSON.parse(\n          line.substring(6).trim().split(\"/\")[1]\n        );\n      }\n    } else if (line.includes(\"$END\")) {\n      currentPage = \"\";\n    } else if (line.includes(\">>\")) {\n      const clearLine = line.substring(2);\n      const [x, y, s, w] = clearLine.split(\"/\")[0].split(\"-\");\n      out[currentPage]?.push({\n        index: clearLine.split(\"/\")[2]\n          ? parseInt(clearLine.split(\"/\")[2])\n          : lastIndex + i,\n        x: parseFloat(x),\n        y: parseFloat(y),\n        size: parseFloat(s),\n        width: parseFloat(w),\n        style: JSON.parse(clearLine.split(\"/\")?.[1]),\n      });\n      lastIndex = clearLine.split(\"/\")[2]\n        ? parseInt(clearLine.split(\"/\")[2])\n        : lastIndex;\n\n      i += 1;\n    } else if (line.length > 1) {\n      if (out[currentPage]?.length > 0) {\n        out[currentPage][out[currentPage]?.length - 1].text = line;\n      }\n    }\n  });\n\n  return out;\n};\n\nexport const parseObjectToPSRT = (sub: {\n  [page: string]: {\n    x: number;\n    y: number;\n    width: number;\n    size: number;\n    text: string;\n    index: number;\n    style: React.CSSProperties;\n  }[];\n}): string => {\n  let out = \"\";\n\n  Object.keys(sub).map((page) => {\n    out += `$START ${page}\\n`;\n    sub[page]?.map(({ x, y, size, width, text, style, index }, i) => {\n      out += `>>${x}-${y}-${size}-${width}/${JSON.stringify(style)}/${\n        index || i\n      }\\n`;\n      out += `${text}\\n\\n`;\n    });\n    out += `$END ${page}\\n\\n`;\n  });\n  return out;\n};\n"]},"metadata":{},"sourceType":"module"}